// Cell types: superficial pyramidal RS; superficial pyramidal FRB;
// superficial basket; superficial axoaxonic; superficial LTS;
// spiny stellate; tufted deep IB; tufted deep RS; nontufted deep RS;
// deep basket; deep axoaxonic; deep LTS; thalamocortical relay (TCR);
// nucleus reticularis thalami (nRT).


//in Fortran version max number of cells of any one type should be 1000; otherwise problems with broadcasting
// axonal potentials

cells_type = 14
objref Map_names[cells_type], Num_pop, Ex_pop, Inh_pop, Fortran_order,Fortran_order_inv,Fortran_order_presyn
{
Map_names[0] = new String("suppyrRS")
Map_names[1] = new String("suppyrFRB")
Map_names[2] = new String("supbask")
Map_names[3] = new String("supaxax")
Map_names[4] = new String("supLTS")
Map_names[5] = new String("spinstell")
Map_names[6] = new String("tuftIB")
Map_names[7] = new String("tuftRS")
Map_names[8] = new String("nontuftRS")
Map_names[9] = new String("deepbask")
Map_names[10] = new String("deepaxax")
Map_names[11] = new String("deepLTS")
Map_names[12] = new String("TCR")
Map_names[13] = new String("nRT")
}

// To obtain the some result like in previous version, to have the same random nubers
// I have to create random connections in the same order like in Fortran version
{Fortran_order = new Vector()
//Fortran_order_inv = new Vector()
Fortran_order.append(0,1,2,3,4,5,6,7,9,10,11,12,13,8)
//Fortran_order_inv.append(0,1,2,3,4,5,6,7,11,8,9,10,12,13)

Fortran_order_presyn = new Vector()
Fortran_order_presyn.append(0,1,2,3,4,5,6,7,9,10,11,12,13,8)
}
//denition of population's size
//position 0 refers to suppyrRS
//	   1 refers to suppyrFRB 
//	   2 refers to supbask
//	   3 refers ro supaxax
//	   4 refers to supLTS
//	   5 refers to spinystellate
//	   6 refers to tuftIB
//	   7 refers to tuftRS
//	   8 refers to notuftRS
//	   9 refers to deepbask
//	   10 refers to deepaxax
//	   11 refers to deepLTS
//	   12 refers to TCR
//	   13 refers to nRT

{Num_pop = new Vector()

//     num_spinstell = 240, num_tuftIB = 500, num_tuftRS = 500,
//    Diego unsure how many tuftRS there are

Num_pop.append(1000,50,90,90,90,240,800,200,500,100,100,100,100,100)}

//Ex_pop - which populations are exicitory
//Inh_pop - which populations are inhibitory
{Ex_pop = new Vector()
Inh_pop = new Vector()

Ex_pop.append(0,1,5,6,7,8,12)
Inh_pop.append(2,3,4,9,10,11,13)
}

//to have smaller network (1/10)
if (one_tenth_ncell) {
	Num_pop.div(10)
}

//special compartments in every cells :
//Axon_comps - presynaptic comp
//Num_comp - compartments defined as IS in Traub model - see commentary bellow

// Compartments contacted by axoaxonic interneurons are IS only
// (I think IS stands for Initial Segment - tmmm)
objref Num_comp,Axon_comps

{Num_comp = new Vector()
Num_comp.append(74,74,59,59,59,59,61,61,50,59,59,59,137,59)

Axon_comps = new Vector()
Axon_comps.append(72,72, 59,59,59,57,60,60,48,59,59,59,135,59)}



//definition of numbers of connections beetwen populations (Num_connect) and definition of number of compartments that can be
// contacted for each type of synaptic connection (Num_connect_compallow)
objref Num_connect, Connect_file, Num_connect_compallow, Num_connect_compallow_file

strdef tmp_str


open_file_to_read(params_dir,"connections.dat",Connect_file)

{Num_connect = new Matrix()
Num_connect.scanf(Connect_file, cells_type, cells_type)
Connect_file.close()}


open_file_to_read(params_dir,"connections_ncomp_allow.dat",Num_connect_compallow_file)

{Num_connect_compallow = new Matrix()
Num_connect_compallow.scanf(Num_connect_compallow_file, cells_type, cells_type)
Num_connect_compallow_file.close()}


//gj
// Note that gj form only between cells of a given type 
//  except suppyrRS/suppyrFRB   tuftIB/tuftRS
// gj/cell = 2 x total gj / # cells

objref totgj, num_gjcompallow, gapcon//, totmixgj
{totgj = new Vector()
totgj.append(722,4,200,0,200,240,350,350,500,250,0,250,100,250)
}

//suppyrRS/suppyrFRB gj
totaxgj_suppyr    =  74 

//tuftIB/tuftRS gj
//          totaxgj_tuft      = 350 
totaxgj_tuft      =  10 // decr. antidr. bursts in IB 
// Note: no gj between axoaxonic cells.


// Define number of compartments on a cell where a gj might form
{
num_gjcompallow = new Vector()
num_gjcompallow.append(1,1,8,0,8,1,1,1,1,8,0,8,1,8)

// for NEURON conversion do gap junctions need to be multiplied by a conversion
// factor?  
// Define gap junction conductances.

gapcon = new Vector()
gapcon.append(3.e-3,3.e-3,1.e-3,0,1.e-3,3.e-3,4.e-3,4.e-3,4.e-3,1.e-3,0,1.e-3,0,1.e-3)
}

//commentary from prior version different values of gapcon
//          gapcon_suppyrRS  = 0.e-3 // to see if superf. lay. can follow 40 Hz
//          gapcon_suppyrFRB = 0.e-3 // to see if superf. lay. can follow 40 Hz
//          gapcon_spinstell = 0.e-3 // to see if ctx follows 40 Hz from thal.
//          gapcon_tuftIB    = 0.e-3 // to decr. antidr. bursting
//          gapcon_tuftRS    = 0.e-3 // now follow 40 Hz?
//          gapcon_nontuftRS = 0.e-3 // to abolish VFO in lay. 6
//          gapcon_TCR       = 3.e-3



dt = 0.002e0
Mg = 1.50
// Castro-Alamancos J Physiol  disinhib. neocortex in vitro  uses
// Mg = 1.3
             

NMDA_saturation_fact= 80.e0
//                                        = 5.e0

// NMDA conductance developed on one postsynaptic compartment 
// from one type of presynaptic cell  can be at most this
// factor x unitary conductance
// UNFORTUNATELY  with this scheme,if one NMDA cond. set to 0
// on a cell type, all NMDA conductances will be forced to 0
// on that cell type...

thal_cort_delay = 1.e0
cort_thal_delay = 5.e0
     how_often = 50
//how_often = 50 - important in Fortran version but is it used in Neuron version?
// how_often defines how many time steps between synaptic conductance
// updates, and between broadcastings of axonal voltages.
axon_refrac_time = 1.5e0 //is it used somewhere?

// For these ectopic rate s, assume noisepe checked
// every 200 time steps = 0.4 ms = 1./2.5 ms

//amplitude of ectopic current
ectopic_pulse = 0.4


objref noisepe
a = 1.0 / (2.5e0 * 1000.e0)
{noisepe = new Vector()
noisepe.append(a/10,a/10,0,0,0,0,a,a,a,0,0,0,a,0)}

 //         noisepe_suppyrRS   = 1.e0 / (2.5e0 * 10000.e0) 
//                 1.d0 / (2.5e0 * 1000.e0) // USUAL


// Synaptic conductance time constants. 
objref tauNMDA, tauGABA, tauAMPA, tauNMDA_file, tauAMPA_file, tauGABA_file, tauGABA2

{open_file_to_read(params_dir,"tau_nmda.dat",tauNMDA_file)
tauNMDA = new Matrix()
tauNMDA.scanf(tauNMDA_file, cells_type, cells_type)
tauNMDA_file.close()


open_file_to_read(params_dir,"tau_ampa.dat",tauAMPA_file)
tauAMPA = new Matrix()
tauAMPA.scanf(tauAMPA_file, cells_type, cells_type)
tauAMPA_file.close()

open_file_to_read(params_dir,"tau_gaba.dat",tauGABA_file)
tauGABA = new Matrix()
tauGABA.scanf(tauGABA_file, cells_type, cells_type)
tauGABA_file.close()

//only in thalamus
tauGABA2 = new Vector()
tauGABA2.append(0,0,0,0,0,0,0,0,0,0,0,0,30.e0,89.e0 )}
//         tauGABA1_nRT_to_TCR             =10.e0 
//         tauGABA2_nRT_to_TCR             =30.e0 
//         tauGABA1_nRT_to_nRT             =18.e0 
//         tauGABA2_nRT_to_nRT             =89.e0 
// See notebook entry of 17 Feb. 2004.
// Speed these up per Huntsman & Huguenard (2000)
          tauGABA1_nRT_to_TCR             =3.30e0 
          tauGABA2_nRT_to_TCR             =10.e0 
         tauGABA1_nRT_to_nRT             = 9.e0 
         tauGABA2_nRT_to_nRT             =44.5e0 

// End definition of synaptic time constants

// Synaptic conductance scaling factors.

objref gNMDA, gGABA, gAMPA, gNMDA_file, gAMPA_file, gGABA_file, nRT_gGABA_vec

{open_file_to_read(params_dir,"g_nmda.dat",gNMDA_file) 
gNMDA = new Matrix()
gNMDA.scanf(gNMDA_file, cells_type, cells_type)
gNMDA_file.close()

open_file_to_read(params_dir,"g_ampa.dat",gAMPA_file) 
gAMPA = new Matrix()
gAMPA.scanf(gAMPA_file, cells_type, cells_type)
gAMPA_file.close()

open_file_to_read(params_dir,"g_gaba.dat",gGABA_file) 
gGABA = new Matrix()
gGABA.scanf(gGABA_file, cells_type, cells_type)
gGABA_file.close()}

{localloadfile("durand.hoc")}

//ranvec_nRT = durand(seed,num_nRT+1,ranvec_nRT)
//gGABA_nRT_to_TCR = ranvec_nRT.mul(1.4e-3).add(0.7e-3).c




/*//      gGABA_supbask_to_spinstell  =0.7e-3
       gGABA_supbask_to_spinstell  =0.1e-3 // if main inhib. to spinstell from deep int.*/

/*//      gGABA_supaxax_to_spinstell  =1.0e-3
       gGABA_supaxax_to_spinstell  =0.1e-3 // if main inhib. to spinstell from deep int.*/



/*//      gGABA_deepbask_to_spinstell =1.0e-3
       gGABA_deepbask_to_spinstell =1.5e-3 // ? suppress spiny stellate bursts ?*/

/*
//      gGABA_deepaxax_to_spinstell  =1.0e-3
       gGABA_deepaxax_to_spinstell  =1.5e-3 // ? suppress spiny stellate bursts ?*/

/*      
//      gGABA_deepLTS_to_tuftIB      =.02e-3
       gGABA_deepLTS_to_tuftIB      =.05e-3 // will this help suppress bursting?*/

/*
//      gAMPA_TCR_to_supbask         =1.0e-3
       gAMPA_TCR_to_supbask         =0.1e-3*/
// try a variation in which main feedforward inhibtion from thalamus
// is via deep interneurons.  May be necessary later to include special
// layer 4 interneurons

/*
//      gNMDA_TCR_to_supbask         =.10e-3
       gNMDA_TCR_to_supbask         =.01e-3
//      gAMPA_TCR_to_supaxax         =1.0e-3
       gAMPA_TCR_to_supaxax         =0.1e-3
//      gNMDA_TCR_to_supaxax         =.10e-3
       gNMDA_TCR_to_supaxax         =.01e-3
*/


/*//      gAMPA_TCR_to_deepbask        =1.0e-3
       gAMPA_TCR_to_deepbask        =1.5e-3
*/

//      gGABA_nRT_to_TCR             =1.0e-3





// End defining synaptic conductance scaling factors

// Begin definition of compartments where synaptic connections
// can form.
// Note: many of these arrays used to be INTEGER in FORTRAN.  Since all
// arrays in NEURON are double  that is why they are now double.
// all the plus ones added to the array bounds allow the use of FORTRAN
// index bounds (starting at 1 instead of 0)


objref Compallow[cells_type][cells_type], Compallow_file, readline

open_file_to_read(params_dir,"comp_allow.dat",Compallow_file) 

//which compartments are allowed in conections from one population to another

for i=0,cells_type-1{
	for j = 0,cells_type-1{
		readline = new Vector()
		k = Num_connect_compallow.x[i][j]
		if (k > 0){
			readline.scanf(Compallow_file,k)
			}else{
			readline.scanf(Compallow_file,1)
			}
		
		Compallow[i][j]=readline.c()
		}

	}



/*

//	objref compallow_spinstell_to_suppyrRS
//	compallow_spinstell_to_suppyrRS=new Vector()
// {compallow_spinstell_to_suppyrRS.append(0.1,  40,41,42,43,44,45,46,47,48,49,50,51,52)}

//	objref compallow_spinstell_to_suppyrFRB
//	compallow_spinstell_to_suppyrFRB=new Vector()
// {compallow_spinstell_to_suppyrFRB.append(0.1, 40,41,42,43,44,45,46,47,48,49,50,51,52)}

// 3 Mar. 2004: Feldmeyer, ..., Sakmann, J Physiol 2002 assert
// that in barrel ctx, spiny stellates go to basal dendrites of
// layer 2/3 pyramids

*/



// Entries in gjtable(fixed_row,col 1-4) are cell a, compart. of cell a with gj, 
//  cell b, compart. of cell b with gj; entries not repeated 
// which means that for given cell being integrated table 
// must be searched through cols. 1 and 3. 

 
//     comment for above: 
// gjtable_suppyr for suppyrRS/suppyrFRB gj, with RS cell 
// in col. 1 and FRB cell in col. 3 
// gjtable_tuft for tuftIB/tuftRS gj, with IB cell 
// in col. 1 and RS cell in col. 3. 
 
 
// define compartments on which gj can form 


// above was duplicated and split up to assign values:
// define compartments on which gj can form 
// note an extra 0.1 value is appended first to shift the indicies
// to FORTRAN style values start at index 1. 
// 0.1 will generate an
// error if ever accidentally used which will indicate that the index
// should have started at the next value (1 instead of index 0)

///////////////////////////////////////
//
//where gj junctions can form
//
//////////////////////////////////////

objref GjCompallow[cells_type], GjCompallow_file, gj_readline

open_file_to_read(params_dir,"gj_comp_allow.dat",GjCompallow_file) 


for i=0,cells_type-1{
	gj_readline = new Vector()
	k = num_gjcompallow.x(i)
	if (k > 0){
		gj_readline.scanf(GjCompallow_file,k)
		}else{
		gj_readline.scanf(GjCompallow_file,1)
		}
	
	GjCompallow[i] = gj_readline.c()
}

 
// have it any meaning in Neuron?
        objref dexptablesmall // these actually have fortran values at
        objref  dexptablebig  // index 0 (see groucho.f)
       { dexptablesmall= new Vector(5000+1) // these actually have fortran values at
        dexptablebig= new Vector(1000+1)}  // index 0 (see groucho.f)



// Define arrays, constants, for voltages, applied currents, 
// synaptic conductances, random numbers, etc. 



//display = 1

if (pmesg) print "Initializing Network"
if (small_model) {
	small_size_network = 40
	if (pmesg) print "In test case only ",small_size_network,"cells of each type are created"
	Num_pop.mul(0).add(40)
}

pnm.ncell = Num_pop.sum()

gid_distribute()
if (pmesg) print "creating ", pnm.ncell," cells:"
if (pmesg) print ""

base_=-1	// variable keeps track of where cells start
// to find the nth cell of type celltype use celltype_base+n as
// index in cells list.
// Note that this converts a fortran style index 1, num_celltype
// to the cells list index (0, total_num_of_cells-1)


space_between_cells = 10 // microns



{localloadfile("../net/create_cell.hoc")}

for j =0,13{
create_cells(j,Map_names[j].s, Num_pop.x(j)) }
par_register_cells()



if (pmesg) print "Done creating cells"


//	maybe this value will be used for a NEURON version of Traub's
//	choice of a random number generator:

	objref seed
	{seed = new Vector()
        seed.append(137.e0)}

          time1 = 0.e0	//	 used to be =gettime()

// the AMPA, NMDA, and GABA_A synapses are all
// alpha functions g = delta exp( -delta/tau )



objref presyn_comps

{presyn_comps = new Vector()
presyn_comps.append(72,72,59,59,59,57,60,60,48,59,59,59,135,59)}


// Construct synaptic connectivity tables
         display = 0
	thisno = 0 // thisno is only required for the display
	// of sample settings in the called subroutines below:
	// in the FORTRAN code it represents the (mpi) rank of the process.

//{localloadfile("durand.hoc")}
{localloadfile("synaptic_map_construct.hoc")}
{localloadfile("synaptic_compmap_construct.hoc")}


///////////////////////////////////////////////////
//
//Construction of synaptic compartment Map_names
//
///////////////////////////////////////////////////

//map_ contains information which cell give projections to which cell

objref map_[cells_type][cells_type], com_[cells_type][cells_type], tmp_s

{tmp_s = new String()}

for it = 0,cells_type-1{
	ord_i =  Fortran_order_presyn.x(it)
	for j = 0,cells_type-1{
		ord_j = Fortran_order.x(j)
		
		if (Num_connect.x[ord_i][ord_j] >0) {
			sprint(tmp_s.s, "map_%s_to_%s",Map_names[ord_i].s, Map_names[ord_j].s)
			map_[ord_i][ord_j] =(synaptic_map_construct( thisno, Num_pop.x(ord_i) , Num_pop.x(ord_j)   , Num_connect.x[ord_i][ord_j]    ,  display, tmp_s.s))}

	
		}

}

//comp_ contains information abot pre- od post- synaptic components in connections formed between cells defined in map_

for it = 0,cells_type-1{
	ord_i = Fortran_order_presyn.x(it)
	for j = 0,cells_type-1{
		ord_j = Fortran_order.x(j)

		if (Num_connect.x[ord_i][ord_j] >0){
			sprint(tmp_s.s, "comp_%s_to_%s",Map_names[ord_i].s, Map_names[ord_j].s)
			com_[ord_i][ord_j] = (synaptic_compmap_construct(thisno, Num_pop.x(ord_j) , Num_connect.x[ord_i][ord_j],  Num_connect_compallow.x[ord_i][ord_j], Compallow[ord_i][ord_j] ,  display, tmp_s.s))
		}
		
	}
}

/////////////////////////////////////////////////////////
//
// Finished construction of synaptic compartment Map_names. 
//
/////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////
//
// Construct gap-junctions
//
/////////////////////////////////////////////////////////
if (pmesg)           print "Construct gap-junction tables"



//	{localloadfile("groucho_gapbld.hoc")}
//	{localloadfile("groucho_gapbld_mix.hoc")}


objref all_gap[cells_type], used, tmp_gap1, tmp_gap2,comps,used,  rand_gap_print

if (display){
	rand_gap_print = new File()

	if (pc.id == 0){
		rand_gap_print.wopen("gap_con.out")}

	pc.barrier()
	rand_gap_print.aopen("gap_con.out")}


localloadfile("groucho_gapbld.hoc")
localloadfile("groucho_gapbld_mix.hoc")

proc gap_connect(){local gj,it,j localobj used,comps
	comps = new Vector()
	j = $1
	used = new Matrix(Num_pop.x(j),Num_pop.x(j) )
	num_allowedcomps = num_gjcompallow.x(j)
	
	gj = totgj.x(j)

	for it = 0, gj-1{
		
		base = -1
		if (j > 0){ base = pop_base.x(j-1) }
		comps = rand_gap(used,comps,Num_pop.x(j),j)		
		par_gap_create(comps.x(0)+ base, comps.x(2), comps.x(1)+base, comps.x(3),gapcon.x(j))
		}
}



proc gap_mix_connect(){local gj,i,base2,base1 localobj comps
	used = new Matrix(Num_pop.x($1),Num_pop.x($2) )
	comps = new Vector()
	
num_allowedcomps = num_gjcompallow.x($1)
	for i = 0, $3-1{
		//print i
		base1 = -1
		if ($1 != 0){ base1 =pop_base.x($1 - 1) }
		base2 = pop_base.x($2 - 1)
		comps = rand_gap_mix(used,comps,Num_pop.x($1),Num_pop.x($2),$1,$2)		
		par_gap_create(comps.x(0)+ base1, comps.x(2), comps.x(1)+base2, comps.x(3),gapcon.x($1))
		}


}
////////////////////////
// axonal gap junctions
////////////////////////


//for pyramids in L2/3
for j = 0,1{
	gap_connect(j)
}
//

//between suppyrRS an suppyrFRB
gap_mix_connect(0,1,totaxgj_suppyr)

//for spiny, tuftIB, tuftRS
for j = 5,7{
	gap_connect(j)
}

//between tuftIB and tuftRS
gap_mix_connect(6,7,totaxgj_tuft)


//betwen nontuftRS 
j = 8
	gap_connect(j)



////////////////////////
// dendritic gap junctions
////////////////////////
for j = 2,4{
	gap_connect(j)
}

for j = 9, cells_type -1{
	gap_connect(j)
}
if (display){
	rand_gap_print.close()}

//////////////////////////////////////////////////////////
//
// End of construction of gap-junctions
//
/////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////
//
// Define synapse, current injection strengths
//
/////////////////////////////////////////////////////////


//only nRT_gGABA has the random GABA weight
{nRT_gGABA_vec = new Vector()
nRT_gGABA_vec = durand(new Vector(),Num_pop.x(13)+1 ,nRT_gGABA_vec)
nRT_gGABA_vec.mul(1.4e-3).add(0.7e-3)}

proc gaba_weight_read() { localobj f, s
	s = new String()
	sprint(s.s, "../../p2c/other_rnd/%s", $s2)
	f = new File()
	f.ropen(s.s)
	$o1.scanf(f, $o1.size-1)
	$o1.resize($o1.size+1)
	$o1.rotate(1,0)
	if (pmesg) $o1.printf("%g\n")
}

	if (use_p2c_net_connections) {
		gaba_weight_read(nRT_gGABA_vec, "gGABA_nRT_to_TCR.dat")
	}


////////////////////////////////////////////////////
//
// Define tonic currents to different cell types
//
///////////////////////////////////////////////////

// the following were current vectors that create an arbitrary amount of injected
// current in compartments in the cells, used during integration of the network
// These should be implemented in mod files as curr_inject mechanism that is
// inserted into each compartment desired as a point process.  Then the variables
// const.curr_inject and rand_mag.curr_inject determine the constant portion and
// the random portion of current injection into that compartment.
 
//       double \
	objref curr_suppyrRS

// These vectors were used to supply random tonic and/or phasic currents
// to cells.  These rolls are given in NEURON to mechanisms.



if (pmesg)	print "Adding constant random current injections to the somas"
if (pmesg)	print "  of some cell types."

objref ranvec[cells_type], mul_vec, add_vec, curr[cells_type]

{mul_vec = new Vector()
add_vec = new Vector()}


{mul_vec.append(0.05, 0.1, 0.02, 0,0,0, 0.1, 0.1, 0.1,0,0,0, 0.01,0.05 )
add_vec.append(-0.025, 0.25, 0, 0,0,0, awake,awake, awake*0.75, 0, 0, 0,0, 0.1)}


for case (&j, 0,1,2,5,6,7,8,13,12){
	ranvec[j] = durand(new Vector(), Num_pop.x(j) +1 ,new Vector())
	curr =ranvec[j].mul(mul_vec.x(j)).add(add_vec.x(j)).c
	base_ = -1
	if (j > 0){ base_ = pop_base.x(j-1) }
	set_const_curr_inj(base_, Num_pop.x(j), curr)
	}

if (pmesg)	print "Completed adding constant random current injections."

//add some additional current to stimulate the network (e.g. to thalamus)
//works only if use_input_curr = 1
set_input_curr( pop_base.x(11), Num_pop.x(12), 3, 2,120)

//possible different values:


	//curr_tuftIB    =ranvec_tuftIB   .mul( 0.0e0).c
//       curr_tuftIB    (1,L) = 0.10e0 + 0.1e0 *
//       curr_tuftIB    (1,L) = -1.00e0 + 0.1e0 * // ? suppress intrinsic bursting
//       curr_tuftIB    (1,L) = 1.00e0 + 0.1e0 *  //  ? wake up cortex ?

//       curr_tuftRS    (1,L) = 0.10e0 + 0.1e0 *
//       curr_tuftRS    (1,L) = 1.00e0 + 0.1e0 *  //  ? wake up cortex?

//       curr_nontuftRS  (1,postsyn_cell_num) = 0.75e0 + 0.1e0 *  // ? wake up cortex

// During sz, curr to TCR can be zero

//       curr_TCR        (1,postsyn_cell_num) = 1.40e0 + 0.01e0 *


	//ranvec_TCR       = durand(seed,num_TCR +1      ,ranvec_TCR       )
	//ran_TCR = randobj.repick()
	//curr_amp_TCR        =ran_TCR *( 0.1e0) +(0.00e0)
	//curr_amp_TCR        =ran_TCR *( 0.01e0) +(0.00e0)
//       curr_TCR        (1,postsyn_cell_num) = 1.40e0 + 0.01e0 
	//set_input_curr(TCR_base, num_TCR, 1.5, 4, 1)

//	set_input_curr(TCR_base, num_TCR, 3, 2,70)


////////////////////////////////////////////////////
//
// End define tonic currents to different cell types
//
///////////////////////////////////////////////////


////////////////////////////////////////////
//
// NMDA, AMPA, GABA weight scaling
//
/////////////////////////////////////////////


cort_inh_size = Inh_pop.size() -1
cort_ex_size = Ex_pop.size() -1

// CODE BELOW FOR "PICROTOXIN": scale all GABA-A
if (picrotoxin) {
        z1 = 0.06e0  // for intracortical IPSCs
        z2 = 1.00e0  // for intrathalamic IPSCs, usual 1.00
        //z1 = 1.25e0
       //z2 = 1.25e0
	//cort_inh_size = Inh_pop.size() -2
	for i = 0, cort_inh_size -1{
		for j = 0,cells_type -1{
			tmp_pop = Inh_pop.x[i]
			//print gGABA.x[tmp_pop][j] , "gGABA.x[tmp_pop][j]"
			gGABA.x[tmp_pop][j] *= ( z1 )
			}
		}
	nRT_gGABA_vec.mul(z2)
	gGABA.x[13][12] *= z2
	}

// Code below is "NBQX": scale all AMPA
if (NBQX){
//          z1 = 1.00e0  // intracortical e/i
           z1 = 1.00e0  // intracortical e/i // usual 1.00
           z3 = 1.00e0  // TCR -> cortical i // usual 1.0 \
           z4 = 1.00e0  // TCR -> nRT  nontuftRS ->nRT // usual 1.00
           z2 = 2.00e0  // everything else; note that this may be INCREASED, usual 1.0

	for i = 0, cells_type -1{
		for j = 0,cells_type -1{
			gAMPA.x[i][j] *= z2
			}
		}

	for i = 0, cort_ex_size-1{
		for j = 0,cort_inh_size -1{
			gAMPA.x[Ex_pop.x[i]][Inh_pop.x[j]] *= z1/z2
			}
		}
	
	for j = 0,cort_inh_size -1{
			gAMPA.x[12][Inh_pop.x[j]] *= z3/z2
			}
	// TCR -> nRT 
	gAMPA.x[12][13] *= z4/z2

	//nontuftRS ->nRT
	gAMPA.x[8][13] *= z4/z2
	


}

// Code below scales TCR output to cortex (not to nRT), AMPA  NMDA
if (scale_TCR_output) {
	z = 0.e0
	
	for j = 0,cells_type -3{
		gAMPA.x[12][j] *= z
		gNMDA.x[12][j] *= z
		}
	}


// Code below scales some/all NMDA conductances.
	//scale_NMDA_conductances = 1 // mimics default execution of 
	
//print "scale_NMDA_conductances", scale_NMDA_conductances
if (scale_NMDA_conductances) {
         z1 = 0.2e0 // to interneurons
//        z1 = 0.5e0 // to interneurons
// Usual scaling of NMDA to princ. cells, including FRB, is 0.5
         z2 = 2.5e0 // to  cort. principal cells, except FRB
         z3 = 2.5e0 // to suppyrFRB
         z4 = 0.2e0  // to TCR and nRT and from TCR to cort. princ.

	for i = 0, Ex_pop.size()-1{
		for j = 0,cort_inh_size -1{
			gNMDA.x[Ex_pop.x[i]][Inh_pop.x[j]] *= z1
			}
		}

	for i = 0, cort_ex_size-1{
		for j = 0,cort_ex_size -1{
			gNMDA.x[Ex_pop.x[i]][Ex_pop.x[j]] *= z2
			}
		}

	
	for i = 0, cort_ex_size-1{
			//to suppyrFRB
			gNMDA.x[Ex_pop.x[i]][1] *= ( z3/z2 )
		
			//to TCR
			gNMDA.x[Ex_pop.x[i]][12] *= z4

			//to nRT
			gNMDA.x[Ex_pop.x[i]][13] *= z4	

			//from TCR
			gNMDA.x[12][Ex_pop.x[i]] *= z4		
			}

	//from TCR to nRT z1 not z4
	gNMDA.x[12][13] *= z1



}
       

////////////////////////////////////////////
//
// NMDA, AMPA, GABA weight scaling
//
/////////////////////////////////////////////




/////////////////////////////////////////////
//
//Creating synapses
//
/////////////////////////////////////////////

objref postsyncell_, syn_, syn2_
threshold = 0


// j postsyncell
for j = 0,cells_type-1{
	ord_j = Fortran_order.x[j]
	// used to start setting values
	base2 = -1
	if (ord_j > 0){ base2 = pop_base.x(ord_j-1) }
	for i = 0,cells_type-1{
		ord_i = Fortran_order.x[i]
		base1 = -1
		//print i,j
		if (ord_i > 0){ base1 = pop_base.x(ord_i-1) }
		ampa_weight = gAMPA.x[ord_i][ord_j]
		nmda_weight = gNMDA.x[ord_i][ord_j]	
		gaba_weight = gGABA.x[ord_i][ord_j]
		delay = default_delay 
		if ((ord_i == 12) && (ord_j < 12)){delay = thal_cort_delay}else{
		if ((ord_i < 12) && (ord_j > 11)){delay = cort_thal_delay}}

		if ((ord_i == 13) && (ord_j == 13)){	gaba_weight *= 0.56
					}



		for postsyn_cell_num = 1,Num_pop.x(ord_j) if (gidexist(base2+postsyn_cell_num)) {	

			 //print postsyn_cell_num
			  for k = 0, Num_connect.x[ord_i][ord_j]-1{
				a = map_[ord_i][ord_j].x[k][postsyn_cell_num -1]+1
				m = com_[ord_i][ord_j].x[k][postsyn_cell_num -1]
				postsyncell_ = cellobj(base2+postsyn_cell_num)

				if((ord_i == 13) && (ord_j ==12)) {
					gaba_weight = 0.625 *nRT_gGABA_vec.x(a)
				}
				if (!section_exists("comp", m, postsyncell_)) { print "comp not ex", m,ord_i,ord_j,Num_connect.x[ord_i][ord_j]
				continue }
				if (Ex_pop.contains(ord_i)){

					//AMPA and NMDA connections
					
	    				postsyncell_.comp[m] syn_ = new AMPA(0.5)
	   				postsyncell_.synlist.append(syn_)
	    				syn_.tau = tauAMPA.x[ord_i][ord_j]
					if (syn_.tau == 0){print "tauAMPA",m,ord_i,ord_j}

	    				// connect to presynaptic cell:
        				// arguments (presyn cell #     , postsyn cell #                  , synapse #                     , weight     , delay)
	    				nc_append(base1 + a, base2 + postsyn_cell_num, postsyncell_.synlist.count()-1, ampa_weight, delay)

	    				// place NMDA synapse in compartment k of postsynaptic cell postsyn_cell_num:
	    				postsyncell_.comp[m] syn_ = new NMDA(0.5)
	    				postsyncell_.synlist.append(syn_)
					if (syn_.tau == 0){print "tauNMDA",m,ord_i,ord_j}
	    				syn_.tau = tauNMDA.x[ord_i][ord_j]

	   			 	// connect to presynaptic cell:
        				// arguments ( presyn cell #   , postsyn cell #                  , synapse #                     , weight     , delay)
	    				nc_append(base1 + a, base2 + postsyn_cell_num, postsyncell_.synlist.count()-1, nmda_weight, delay)
					}else{
						
					//GABA connections
					
					postsyncell_.comp[m] syn_ = new GABAA(0.5)
	   				postsyncell_.synlist.append(syn_)
	    				syn_.tau = tauGABA.x[ord_i][ord_j]

					if (ord_j > 11){

						// different GABA connections from nRT	
			
						postsyncell_.comp[m] syn2_ = new GABAA(0.5)
	   					postsyncell_.synlist.append(syn2_)
	    					syn2_.tau = tauGABA.x[ord_i][ord_j]

							scale_ = 0
							nc_append(base1 + a, base2 + postsyn_cell_num, postsyncell_.synlist.count()-2, gaba_weight, delay)
							if (ord_j == 12){
								//gaba_weight = nRT_gGABA_vec.x(a)
								scale_ = 0.375/0.625
								syn2_.tau = tauGABA2_nRT_to_TCR
							}else {
								scale_ = 0.44/0.56 
								syn2_.tau = tauGABA2_nRT_to_nRT	
								}
	   			 	 		// connect to presynaptic cell:
        						// arguments ( presyn cell #   , postsyn cell #                  , synapse #                     , weight     , delay)
							nc_append(base1 + a, base2 + postsyn_cell_num, postsyncell_.synlist.count()-1, scale_*gaba_weight  , delay)
						
						}else{

					//if connection is not from nRT

	   			 	// connect to presynaptic cell:
        				// arguments ( presyn cell #   , postsyn cell #                  , synapse #                     , weight     , delay)
	    				nc_append(base1 + a, base2 + postsyn_cell_num, postsyncell_.synlist.count()-1, gaba_weight, delay)}
					}
          			}

			}
		}
	}

///////////////////////////////////////////////////////
//
//End creating synapses
//
///////////////////////////////////////////////////////



//////////////////////////////////////////////////////////
//
// Define phasic currents to suppyrRS cells, ectopic spikes,
// tonic synaptic conductances
//
////////////////////////////////////////////////////////////

/*  this original fortran code:
    if (mod(O,200).eq.0) then

       ranvec_suppyrRS = durand(seed,num_suppyrRS+1 ,ranvec_suppyrRS) 
        for postsyn_cell_num = 1, num_suppyrRS {
         if ((ranvec_suppyrRS(postsyn_cell_num).gt.0.e0).and. \
          (ranvec_suppyrRS(postsyn_cell_num).le.noisepe_suppyrRS)) then
          curr_suppyrRS(72,postsyn_cell_num) = 0.4e0
          ectr_suppyrRS = ectr_suppyrRS + 1
         else
          curr_suppyrRS(72,postsyn_cell_num) = 0.e0
         endif 
        }
      endif

provided a change in the current inject into a compartment (72) of the axon of the
suppyrRS cells.  It flipped randomly back and forth between 0.4e0 (units?) and 0
depending on whether each random number fell between 0 <= random <= noisepe_suppyrRS
The FORTRAN random numbers were evenly distributed between 0 and 1.

Perhaps the best way to integrate these currents into NEURON is through a mechanism
(mod file) that is inserted into these cells compartments.
  
*/
// hoc code for above current injections:
// synaptic pulse point processes (pulsesyn.mod) are used along with a netstim
// to inject ectopic currents into the cells.

	spacer = 0 // used to start over NetStim's arbitrary y position's 
	weight = 1	// the weight is unused for the PulseSyn
	delay = 0	// a uniform delay is irrelevant for the NetStim -> PulseSyn
	// connection since it is poisson process
//if (pmesg) 	print "creating ",num_suppyrRS,"NetStim's for pyr"


for case (&i, 0,1,6,7,8,12){
	base = -1
	ord_i = i
	if (ord_i > 0){base = pop_base.x(ord_i-1)  }
        for postsyn_cell_num = 1, Num_pop.x(ord_i) {

/* Note: noisepe_suppyrRS = 1/(2.5*10^4) was used to select the 0.4 nA pulse if 
0 < rand # (between 0 and 1) < noisepe_suppyrRS
What then is the average interpulse interval?
If we rolled the dice 2.5*10^4 times with an even distribution between 0 and 1 we would expect
to get 1 pulse.  How long does it take to roll that many die?  The dice are rolled every 0.4 ms
so it takes 0.4*2.5*10^4 msec = 10^4 msec = 10 sec (of simulation time)
Therefore interval = 0.4 / noisepe_cellname
*/
		par_netstim_create(base + postsyn_cell_num, Axon_comps.x(ord_i), ectopic_pulse, 0.4 /noisepe.x(ord_i))
	}
}


	delay = default_delay


//////////////////////////////////////////////////////////
//
// Eend define phasic currents to suppyrRS cells, ectopic spikes,
// tonic synaptic conductances
//
////////////////////////////////////////////////////////////

if (pmesg) print "at end"
