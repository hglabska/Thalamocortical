obfunc rand_gap(){local k,a,b,m,n,numcells localobj u,x,y,out_vec 

k = 2
numcells = $3
x = new Vector()
y = new Vector()
out_vec = $o2
u = $o1

	seed = new Vector()
	seed.append(137.e0)
//if (j > 0){ base = pop_base.x(j-1) }
		x = durand (seed, k, x)
		y = durand (seed, k, y)
		a = int ( x.x[0] * numcells ) 
		b = int ( x.x[1] * numcells ) 
		
		while(u.x[a][b] == 1){
			rand_gap_print.printf("%d %d  \n", a+1, b+1)
			x = durand (seed, k, x)
			y = durand (seed, k, y)
			a = int ( x.x[0] * numcells ) 
			b = int ( x.x[1] * numcells ) 
				
			}
			if (!one_tenth_ncell) {
					u.x[a][b] = 1
					u.x[b][a] =1
					}
			

			m = GjCompallow[$4].x(int ( y.x[0] * num_allowedcomps ) )
          		n = GjCompallow[$4].x(int ( y.x[1] * num_allowedcomps ))
			
out_vec.append(a+1,b+1,m,n)
if (display){
	rand_gap_print.printf("%f %f %f %f %d %d %d %d \n",x.x[0], x.x[1], y.x[0],y.x[1], a+1, b+1,m,n)	
	}
return out_vec

}
