obfunc rand_gap_mix(){local a,b,m,n,numcells1, numcells2,k localobj u,x1,x2,out_vec,y 
k = 1
numcells1 = $3
numcells2 = $4
x = new Vector()
y = new Vector()
out_vec = $o2
u = $o1
//if (j > 0){ base = pop_base.x(j-1) }
		x1 = durand (new Vector(), k, x1)
		x2 = durand (new Vector(), k, x2)
		a = int ( x1.x[0] * numcells1 ) 
		b = int ( x2.x[0] * numcells2 ) 
		while(u.x[a][b] == 1){
			x1 = durand (new Vector(), k, x1)
			x2 = durand (new Vector(), k, x2)
			y = durand (new Vector(), k+1, y)
			a = int ( x1.x[0] * numcells1 ) 
			b = int ( x2.x[0] * numcells2 ) 
			}

			
			if (!one_tenth_ncell) {
					u.x[a][b] = 1
					}
			//u.x[b][a] =1
			y = durand (new Vector(), k +1, y)

			m = GjCompallow[$5].x(int ( y.x[0] * num_allowedcomps ) )
          		n = GjCompallow[$6].x(int ( y.x[1] * num_allowedcomps ))
			
out_vec.append(a+1,b+1,m,n)
if (display){
	rand_gap_print.printf("%f %f %f %f %d %d %d %d \n",x1.x[0],x2.x[0], y.x[0],y.x[1], a+1, b+1,m,n)		
	}
return out_vec

}

